/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/* Include CMSIS first */
/* Define MCU */

/* TX pin is at PA9 - alternate function AF7 */
#define TX_PIN					(1U<<9)
#define GPIO_ALTERNATE_MODE		0x2 //0b10
#define USART1EN				(1U<<4)
#define UART_DATAWIDTH_8B		(0U<<USART_CR1_M_Pos)
#define UART_PARITY_NONE		(0U<<USART_CR1_PCE_Pos | 0U<<USART_CR1_PS_Pos)
#define UART_STOPBITS_1			(0b00<<USART_CR2_STOP_Pos)

void delay();
void set_ahb1_periph_clock(uint32_t periphs);
void set_apb2_periph_clock(uint32_t periphs);
void usart1_tx_init();
void set_pin_mode(GPIO_TypeDef *GPIOx, uint32_t pin, uint32_t mode);
void uart_parameters_config(USART_TypeDef *USARTx, uint32_t dataWidth, uint32_t parity, uint32_t stopBits);
uint16_t compute_uart_div(uint32_t periphClock, uint32_t baudRate);
void uart_set_baudrate(USART_TypeDef *USARTx, uint32_t periphClock, uint32_t baudrate);
void uart_write(USART_TypeDef *USARTx, uint8_t data);
void set_uart_transfer_direction(USART_TypeDef *USARTx, uint32_t transferDirection);

/* To use printf, __putchar need to be implemente */
int __io_putchar(int ch)
{
	uart_write(USART1, ch);
	return ch;
}

int main(void)
{
	usart1_tx_init();

    /* Loop forever */
	for(;;)
	{
		printf("Hello STM32\n");
		delay();
	}
}

void uart_write(USART_TypeDef *USARTx, uint8_t data)
{
	/* Make sure transmit data register is empty */
	/* Wait until TXE bit is 1 */
	while(!(USARTx->SR & USART_SR_TXE_Msk));

	/* Write value into transmit data register */
	USARTx->DR = data;
}

void delay()
{
	/* Dummy loop for delay */
	for(int i=0; i<320000; i++);
}

/* Function to enable peripheral clock on AHB1 bus */
void set_ahb1_periph_clock(uint32_t periphs)
{
	//RCC->AHB1ENR |= periphs; - used macro alternative
	SET_BIT(RCC->AHB1ENR, periphs);
}

/* Function to enable peripheral clock on APB2 bus */
void set_apb2_periph_clock(uint32_t periphs)
{
	SET_BIT(RCC->APB2ENR, periphs);
}

void usart1_tx_init()
{
	/* Enable clock for TX pin GPIO port */
	set_ahb1_periph_clock(RCC_AHB1ENR_GPIOAEN);

	/* Set TX pin GPIO mode to alternate function */
	set_pin_mode(GPIOA, TX_PIN, GPIO_ALTERNATE_MODE);

	/* Set alternate function to USART */
	GPIOA->AFR[1] &= ~(0b1111<<4); //AFRH9 - zero bits
	GPIOA->AFR[1] |= (0b0111<<4); //AFRH9 - set AF7

	/* Enable clock to USART module */
	set_apb2_periph_clock(USART1EN);

	/* Configure USART parameters */
	uart_parameters_config(USART1, UART_DATAWIDTH_8B, UART_PARITY_NONE, UART_STOPBITS_1);
	uart_set_baudrate(USART1, 16000000U, 115200); //periph_clok = APB2clock
	set_uart_transfer_direction(USART1, USART_CR1_TE);

	/* Enable USART */
	SET_BIT(USART1->CR1, USART_CR1_UE);
}

void set_pin_mode(GPIO_TypeDef *GPIOx, uint32_t pin, uint32_t mode)
{
	/* Clear the relevant bits in MODER register */
	/* Set the relevant bits in MODER register */
	MODIFY_REG(GPIOx->MODER, 0x03<<(POSITION_VAL(pin)*2U), mode<<(POSITION_VAL(pin)*2U));
	/* pin - pin number in (1<<pinNumber) notation */
	/* e.g. pin = (1<<8U), MODER bits position = 16 and 17 */
	/* pin*2 != 16, because of notation */
	/* POSITION_VAL(pin) returns position of bit from (1<<pin) notation */
	/* POSITION_VAL(1<<8U) = 3 -> x<<(2*pin) = x<<16 (for 2 bit x value, shift is for 16 and 17 bit) */
}

void uart_parameters_config(USART_TypeDef *USARTx, uint32_t dataWidth, uint32_t parity, uint32_t stopBits)
{
	/* Clear ParitySelection, ParityControlEnable and WordLength bits, then set them from function arguments */
	MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE | USART_CR1_M, parity | dataWidth);
	/* Clear StopBits, then set stop bits from function arguments */
	MODIFY_REG(USARTx->CR2, USART_CR2_STOP, stopBits);
}

uint16_t compute_uart_div(uint32_t periphClock, uint32_t baudRate)
{
	return (periphClock + (baudRate/2U))/baudRate;
}

void uart_set_baudrate(USART_TypeDef *USARTx, uint32_t periphClock, uint32_t baudrate)
{
	USARTx->BRR = compute_uart_div(periphClock, baudrate);
}

void set_uart_transfer_direction(USART_TypeDef *USARTx, uint32_t transferDirection)
{
	/* Clear TransmitterEnable and ReceiverEnable bits, then set them from function arguments */
	MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, transferDirection);
}
